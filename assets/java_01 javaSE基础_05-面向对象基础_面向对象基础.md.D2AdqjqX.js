import{_ as a,c as l,o as i,a4 as e}from"./chunks/framework.IpiIUH1b.js";const b=JSON.parse('{"title":"面向对象基础","description":"","frontmatter":{},"headers":[],"relativePath":"java/01 javaSE基础/05-面向对象基础/面向对象基础.md","filePath":"java/01 javaSE基础/05-面向对象基础/面向对象基础.md","lastUpdated":1722566031000}'),t={name:"java/01 javaSE基础/05-面向对象基础/面向对象基础.md"},r=e('<h1 id="面向对象基础" tabindex="-1">面向对象基础 <a class="header-anchor" href="#面向对象基础" aria-label="Permalink to &quot;面向对象基础&quot;">​</a></h1><h2 id="面向对象概述" tabindex="-1">面向对象概述 <a class="header-anchor" href="#面向对象概述" aria-label="Permalink to &quot;面向对象概述&quot;">​</a></h2><h3 id="面向对象概述-1" tabindex="-1">面向对象概述 <a class="header-anchor" href="#面向对象概述-1" aria-label="Permalink to &quot;面向对象概述&quot;">​</a></h3><ul><li>面向对象并不是一个技术,而是一种编程思想. 强调以什么形式写代码,以什么思路解决问题</li><li>先学习如果自己设计对象并使用,再学习获取Java提供好的&quot;对象&quot;并使用</li></ul><h2 id="类和对象" tabindex="-1">类和对象 <a class="header-anchor" href="#类和对象" aria-label="Permalink to &quot;类和对象&quot;">​</a></h2><h3 id="类和对象-1" tabindex="-1">类和对象 <a class="header-anchor" href="#类和对象-1" aria-label="Permalink to &quot;类和对象&quot;">​</a></h3><ul><li><p>什么是类?</p><ul><li>是一类具有共同属性和行为事物的描述,可以理解为设计图</li></ul></li><li><p>什么是对象?</p><ul><li>对象是类的实体,是看得见摸得着的实体</li></ul></li></ul><h3 id="类的定义" tabindex="-1">类的定义 <a class="header-anchor" href="#类的定义" aria-label="Permalink to &quot;类的定义&quot;">​</a></h3><ul><li><p>类的组成</p><ul><li>1.属性: 成员变量(类种方法外的变量)</li><li>2.行为: 成员方法(不加static修饰的方法)</li></ul></li></ul><h3 id="对象的使用" tabindex="-1">对象的使用 <a class="header-anchor" href="#对象的使用" aria-label="Permalink to &quot;对象的使用&quot;">​</a></h3><ul><li><p>创建对象使用哪个关键字?</p><ul><li>使用new关键字</li></ul></li><li><p>对象创建完毕直接打印属性什么结果?</p><ul><li>会打印属性对应数据类型的默认初始值</li><li>引用类型为null 整数为0 小数为0.0</li></ul></li></ul><h2 id="对象内存图" tabindex="-1">对象内存图 <a class="header-anchor" href="#对象内存图" aria-label="Permalink to &quot;对象内存图&quot;">​</a></h2><p><img src="https://gitee.com/zhaox010/pic-go-save/raw/master/image/202407271725024.png" alt="image-20240727172546980"></p><h3 id="java内存分配" tabindex="-1">Java内存分配 <a class="header-anchor" href="#java内存分配" aria-label="Permalink to &quot;Java内存分配&quot;">​</a></h3><ul><li><p>栈内存特点?</p><ul><li>方法被调用后,进入栈内存,方法中的变量(局部变量)会随着方法进入栈内存. 当方法调用结束,会从栈内存消失,此时方法中的变量(局部变量)也会消失</li></ul></li><li><p>堆内存特点?</p><ul><li>new出来的内容进堆内存,成员变量跟随对象进入堆内存. 进堆就会开辟空间,产生地址值,该地址在使用完毕后,在系统空闲时间会被Java垃圾回收器清理</li></ul></li></ul><h3 id="对象内存图-单个对象" tabindex="-1">对象内存图(单个对象) <a class="header-anchor" href="#对象内存图-单个对象" aria-label="Permalink to &quot;对象内存图(单个对象)&quot;">​</a></h3><p><img src="https://gitee.com/zhaox010/pic-go-save/raw/master/image/202407271723975.png" alt="image-20240727172329937"></p><h3 id="对象内存图-多个对象" tabindex="-1">对象内存图(多个对象) <a class="header-anchor" href="#对象内存图-多个对象" aria-label="Permalink to &quot;对象内存图(多个对象)&quot;">​</a></h3><p><img src="https://gitee.com/zhaox010/pic-go-save/raw/master/image/202407271723959.png" alt="image-20240727172313899"></p><h3 id="对象内存图-多个对象指向相同" tabindex="-1">对象内存图(多个对象指向相同) <a class="header-anchor" href="#对象内存图-多个对象指向相同" aria-label="Permalink to &quot;对象内存图(多个对象指向相同)&quot;">​</a></h3><p><img src="https://gitee.com/zhaox010/pic-go-save/raw/master/image/202407271724607.png" alt="image-20240727172422555"></p><h3 id="成员变量和局部变量" tabindex="-1">成员变量和局部变量 <a class="header-anchor" href="#成员变量和局部变量" aria-label="Permalink to &quot;成员变量和局部变量&quot;">​</a></h3><ul><li><p>成员变量和局部变量的区别?</p><ul><li>1.类中位置: 成员变量在类中方法外, 局部变量在方法中或者方法声明上</li><li>2.内存中位值: 成员变量在堆内存存储, 局部变量在栈内存存储</li><li>3.生命周期: 成员变量随着对象的创建而存在,随着对象的消失而消失, 局部变量随着方法的调用而存在,随着方法的弹栈而消失</li><li>4.初始化值: 成员变量进入堆内存,有默认初始化值, 局部变量没有,需要先赋值才能使用</li><li><img src="https://gitee.com/zhaox010/pic-go-save/raw/master/image/202407271724742.png" alt="image-20240727172434710"></li></ul></li></ul><h2 id="封装" tabindex="-1">封装 <a class="header-anchor" href="#封装" aria-label="Permalink to &quot;封装&quot;">​</a></h2><h3 id="private关键字" tabindex="-1">private关键字 <a class="header-anchor" href="#private关键字" aria-label="Permalink to &quot;private关键字&quot;">​</a></h3><ul><li><p>private关键字的语义和作用?</p><ul><li>1.是一个权限修饰符</li><li>2.可以修饰成员(成员变量和成员方法)</li><li>3.被private修饰的成员只能在本类中访问</li></ul></li><li><p>被private修饰的成员外界如何使用呢?</p><ul><li>我们要提供对应的被public修饰的getXxx和setXxx方法</li></ul></li></ul><h3 id="this关键字" tabindex="-1">this关键字 <a class="header-anchor" href="#this关键字" aria-label="Permalink to &quot;this关键字&quot;">​</a></h3><ul><li><p>this关键字的语义和作用?</p><ul><li>1.this代表本类对象的引用(地址)</li><li>2.谁调用方法,方法中的this就代表谁</li><li>3.我们使用this来解决局部变量和成员变量重名问题</li></ul></li></ul><h3 id="封装-1" tabindex="-1">封装 <a class="header-anchor" href="#封装-1" aria-label="Permalink to &quot;封装&quot;">​</a></h3><ul><li><p>面向对象三大特征?</p><ul><li>封装,继承,多态</li><li>封装: 将代码的具体实现细节隐藏在类中,不让外界随便访问</li><li>优点: 提高了代码的安全性,复用性</li></ul></li><li><p>封装的体现?</p><ul><li>1.将代码抽取到方法中, 调用者直接使用方法名, 是对代码的封装</li><li>2.将代码抽取到类中, 也是对代码的封装</li><li>3.使用private私有成员变量, 这是对属性的封装, 外界如果使用我们需要提供对应的getXxx和setXxx方法</li></ul></li><li><p>封装的好处?</p><ul><li>1.提高代码的复用性(方法)</li><li>1.提高代码的安全性(私有)</li></ul></li></ul><h2 id="构造方法" tabindex="-1">构造方法 <a class="header-anchor" href="#构造方法" aria-label="Permalink to &quot;构造方法&quot;">​</a></h2><h3 id="构造方法-1" tabindex="-1">构造方法 <a class="header-anchor" href="#构造方法-1" aria-label="Permalink to &quot;构造方法&quot;">​</a></h3><ul><li><p>构造方法的作用及格式?</p><ul><li>本质作用是创建对象</li><li>public 方法名(){}</li></ul></li></ul><h3 id="构造方法的注意事项" tabindex="-1">构造方法的注意事项 <a class="header-anchor" href="#构造方法的注意事项" aria-label="Permalink to &quot;构造方法的注意事项&quot;">​</a></h3><ul><li><p>构造方法的使用注意?</p><ul><li>1.如果我们不提供构造,系统会给一个默认的空参构造</li><li>2.如果我们给出了带参构造,那么系统就不会再提供空参构造了(这时用户就不能使用空参构造创建对象了!)</li><li>结论: 两种构造都提供,用户根据自己情况随意调用</li></ul></li></ul><h3 id="javabean" tabindex="-1">JavaBean <a class="header-anchor" href="#javabean" aria-label="Permalink to &quot;JavaBean&quot;">​</a></h3><ul><li><p>什么是JavaBean?</p><ul><li>就是Java中的一个类,用于封装数据,比如Student,Phone,Car</li></ul></li><li><p>一个标准的JavaBean包含什么?</p><ul><li>1.成员变量: 必须使用private修饰</li><li>2.构造方法: 提供两种,空参带参都提供</li><li>3.成员方法: 必须提供private修饰的成员变量所对应的getXxx和setXxx方法, 其他方法根据需求走</li></ul></li></ul>',37),h=[r];function o(u,n,s,p,c,d){return i(),l("div",null,h)}const q=a(t,[["render",o]]);export{b as __pageData,q as default};
